#include "stdafx.h"
#include <iostream>
#include <locale>
using namespace std;

int main()
{
	setlocale(LC_ALL, "RUS");
	int a = 8;
	const int path = a; //Объявление константы1
	cout << "path = " << path << endl;
	const int path_1 = a + 3; //Объявление константы2
	cout << "path_1 = " << path_1 << endl;
	float f = 2 * a + 1; //Объявление переменной1 вещественного типа
	cout << "f = " << f << endl;
	float f_1 = a / 2; //Объявление переменнйо2 вещественного типа
	cout << "f_1 = " << f_1 << endl;

	float *pr_f = &f;  //Указатель на переменную1
	int const *pr_n = &path; //Указатель на константу1

	float *const fl_1 = &f_1; //Константный указатель на переменную2
	const int *const pr_n_n = &path; //Константный указатель на константу


										  //1.Уменьшить на единицу значения, на которые указывают указатели (для которых возможна данная операция и почему).
	(*pr_f)--; //Возможно, т.к. указатель указывает на переменную
			   //(*ptr_con)--; //Невозможно, т.к. указатель указывает на константу
	(*fl_1)--; //Возможно т.к. указатель указывает на переменную
			   //(*ptr_con_con)--; //Невозможно, т.к. указатель указывает на константу
	cout << endl;

	//2.Вывести на экран значения, на которые указывают данные указатели
	cout << "Указатель на переменную1 = " << *pr_f << endl;
	cout << "Указатель на константу1 = " << *pr_n << endl;
	cout << "Константный указатель на переменную2 = " << *fl_1 << endl;
	cout << "Константный указатель на константу1 = " << *pr_n_n;
	cout << endl;
	cout << endl;

	//3.Изменить адрес указателей (для которых это возможно и почему) на адрес константы2.
	//ptr_fl = &con_1; //Невозможно, т.к. тип const int* нелзя присвоить типу float*
	//ptr_fl_1 = &con_1; //Невозможно, т.к. это константный указатель, адрес которого изменить нельзя
	pr_n = &path; //Возможно, т.к указатель не константный, т.е. его адрес можно изменить
	cout << "pr_n = &path_1 = " << *pr_n << endl;
	//ptr_con_сon = &con_1; //Невозможно, т.к. указатель объявлен как константный, т.е. адрес изменить нельзя
	cout << endl;

	//4. Изменить адрес указателей (для которых это возможно и почему), 
	//на адрес динамически выделенной области памяти под массив вещественных переменных длинной равной значению
	//по указателю на константу.
	pr_f = new float[*pr_n]; //Возможно, т.к. указателю типа float* можно присвоить сущность типа float*
							 //ptr_fl_1 = new float[*ptr_con]; //Невозможно, т.к. это константный указатель
							 //ptr_con = new float[*ptr_con];//Невозможно, т.к. указателю типа const int* невозможно при-своить сущность типа float*
							 //ptr_con_сon = new float[*ptr_con]; //Невозможно, т.к. это константный указатель типа const int*
	cout << endl;

	//5. Проинициаизировать элементы массива с помощью операции косвенного обращения (разыменова-ния) 
	//значением, на которое указывает константный указатель на переменную плюс i / 2,
	//где i порядковый номер элемента массива.
	for (int i = 0; i < *pr_n; i++)
	{
		*(pr_f + i) = (float)(*pr_n) + (float)(i / 2);
	}
	cout << endl;

	//6. И точно так же с помощью разыменования вывести значения элементов одномерного массива на экран.
	for (int i = 0; i < *pr_n; i++)
	{
		cout << " " << *(pr_f + i);
	}
	cout << endl;

	//7. Изменить адрес указателя (для которого это возможно) на адрес последней переменной в массиве.
	pr_f = &(*(pr_f + (*pr_n - 1)));
	cout << "pr_f = " << *pr_f << endl;
	//ptr_fl_1 = &(*(ptr_fl + (*ptr_con))); //Невозможно, т.к. это константный указатель
	//ptr_con = &(*(ptr_fl + (*ptr_con))); //Невозможно, т.к. значению типа const int* нельзя присвоить значение типа float*
	//ptr_con_сon = &(*(ptr_fl + (*ptr_con))); //Невозможно, т.к. это константный указатель
	cout << endl;

	//8. Объявить указатель второго порядка, и записать в него адрес указателя, по адресу которо-го 
	//находится наибольшее значение.
	float **ptr_max = &pr_f;
	cout << endl;

	//9. Вывести на экран значение, которое находится по указателю второго порядка.
	cout << **ptr_max;
	cout << endl;
	system("pause");
	return 0;
}